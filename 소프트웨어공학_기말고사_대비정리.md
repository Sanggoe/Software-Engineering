## 소프트웨어 공학 중요한 내용 정리



## 8 소프트웨어 테스팅

### 검증 테스팅(validation testing)

* 소프트웨어가 '고객의 요구사항'에 맞는지 보여주고, 요구사항마다 적어도 하나의 테스트가 있어야 하지 않느냐는 관점에서의 테스트이며, 시스템이 정확하게 수행되는 것을 목표로 실시한다.
* 결함테스팅와 다르게 '정상적인 데이터'로 프로그램이 의도한대로 잘 돌아가는지 확인을 위한 테스트이다.

### 결함 테스팅(defect testing)

* 소프트웨어의 결함(버그)에 의해 제대로 동작하지 않는 경우를 찾기위한 테스트로, 테스트 케이스(test case)에서 일부로 한계치를 시도해보거나 오류를 발생시키는 방향으로 하는 등 결함(defect)을 드러낼 수 있도록 설계한다.
* 검증테스팅과는 다르게 '이상한 입력'을 통해서 결함을 찾아내는 것을 목표로 한다.

### Verification vs Validation

* Validation은, 올바른 제품을 만들고 있는지, 고객의 기대에 맞는지, 고객에게 도움이 되는 프로그램인지, 고객이 기대하는 것을 제공하는지 등 '이 제품이 맞는지' 대한 것을 말한다.
* Verification은, 제품을 올바르게 만들고 있는지, 소프트웨어가 요구사항 명세에 맞는지, SPEC에 맞는지 등 '제품을 제대로 만들고 있는지'에 대한 것을 말한다.

### 소프트웨어 인스펙션

* 소프트웨어 인스펙션은 정적 V&V 기술로서, 프로그램은 실행시키지 않고 주로 '소스코드'를 대상으로 하는 정적인 프로세스 방법이다. 따라서 오류간의 상호작용과는 무관하며, 소스코드를 읽으면서 한 번에 여러 오류를 발견할 수 있다는 특징이 있다.

### 소프트웨어 테스팅

* 반면에 소프트웨어 테스팅은 프로그램을 실제로 실행시켜서 동작을 관찰하는 동적 V&V 기술이다. 그러나 인스펙션이 테스팅을 대체할 수 없는 등, 둘은 서로 상호 보완적인 관계이다.



### 회귀 테스팅(regression testing) 

* 시스템을 변경한 후 테스트를 수행할 때, 변경과 관련된 버그 뿐 아니라 새로운 코드가 기존의 코드와 문제없이 동작하는지 검사하기 위해 이전에 진행했던 테스팅을 포함해 모든 테스트를 다시 실행하는 방식을 말한다.

### 동등 분할(equivalence partition)

* 단위 테스팅을 할 때 테스트 케이스 선정을 위한 전략의 종류 중 하나로, 입력 또는 출력에 대해서 '공통 특징을 가진 그룹'으로 나누는 것을 말한다. 즉, 입력과 출력 데이터에 대해 나누어서 그룹별로 적어도 하나 이상씩은 테스트 케이스를 선별해야 하지 않겠느냐? 하는 관점으로 테스트 케이스를 선정할 때(분할테스팅) 앞서 공통 특징을 가진 그룹으로 나누는 과정이 동등 분할 과정인 것이다.

### 분할 테스팅(partition testing)

* 입력과 출력 데이터들에 대해 나누어서 그룹별로 적어도 하나 이상씩은 테스트를 해야하지 않겠느냐? 하는 관점으로 테스트 케이스를 선별하여 테스트 하는 방법으로, 분할의 양쪽 경계와 분할의 중간점을 선정하는 것이 일반적이다.

### 코드 커버리지(code coverage)

* 테스트 과정에서 소스 코드 중 실행되어 테스트가 된 비율을 말한다. 관련하여 단순히 코드 몇줄이 수행되었냐에 대한 부분인 문장 커버리지, 결정 또는 분기 커버리지, 조건 커버리지 등이 존재한다.

### 블랙박스(black-box) 테스팅

* 테스트 케이스를 선정할 때 구체적인 코드의 내용이나 시스템 내부의 지식은 알지 못하고 시스템의 명세만을 사용해서 테스트 케이스를 선정하는 방법으로, 동등 분할 기법이 블랙박스 테스팅에 해당한다.

### 화이트박스(white-box) 테스팅

* 알고리즘이나 소스코드 등 내부 구조를 잘 알고있는 상태에서 구조적으로 테스트 케이스를 선정하는 방법을 말하며, 문장 커버리지, 분기 커버리지, 단순경로 기법 등이 화이트박스 테스팅에 해당한다.

### Flow graph

* 흐름그래프. 프로그램 내의 경로를 보여줌

### 순환 복잡도 (Cyclomatic complexity)

*  프로그램에 존재하는 독립적인 경로의 수를 말하며, 경로의 조합은 고려하지 않는다.
* 구하는 방법은 여러가지인데.. 대표적으로
  * 순환복잡도 = 간선(edge) 수 - 노드(node) 수 + 2
  * 순환복잡도 = 단순 조건(if, else if, while, for..)의 수 + 1
* 실수하지 않는 번호 붙이는 방법
  * **조건**에는 번호를 붙인다! 그리고 조건과 실행문이 한 줄에 있지 않도록 꼭 엔터 친다..
  * **return**에도 번호를 붙인다!
  * **메소드의 맨 마지막 닫는 괄호**에도 번호를 붙인다!

### 기본 경로 테스팅(basic path testing) 

* 독립적인 경로를 적어도 한 번은 거치도록 테스트 케이스를 선정하는 방식을 말한다.

### 컴포넌트 테스팅

* 단위 테스트는 완료되었다고 가정하고 컴포넌트의 인터페이스를 테스트하는데 중점을 둔 테스트이다. (인터페이스 테스팅)

### 테스팅 가이드라인

* 일부로 결함(defect)을 발견하도록, 이상한 값으로 테스트 케이스를 만드는게 일반적인 가이드라인이다.

### 스트레스 테스팅(stress testing)

* 시스템의 원래 설계된 최대 부하보다 더 큰 부하를 주어 오류를 발견하는 방법을 말하며, 시스템의 장애 행동을 관찰하거나 결함(defect)을 발견하기 위한 목적으로 수행하는 테스팅 방법이다.
* 예시) 메시지 전달 시스템을 예로 들면, 엄청나게 많은 메시지를 보내는 등의 방법을 통해 고의적으로 컴포넌트가 실패하도록 테스트를 진행한다. 이 때 스트레스 테스팅은 타이밍 문제 등을 발견하는데 효과적인 방법으로 사용된다.



## 9 소프트웨어 진화

### 레거시 시스템

* 더 이상 사용되지 않는 언어나 기술에 의존하는 옛날 기존 시스템을 말한다. 이에 기술자가 부족하거나 보안이 취약하거나 하드웨어 또는 인터페이스와 관련된 많은 문제점이 생기지만, 교체 비용이나 리스크가 커서 또는 아직 잘 돌아간다는 이유로 그대로 사용하곤 한다.
* 그래도 유지시키기 위해 시스템 재공학 등으로 유지보수성을 향상시키기도 한다.

### 시스템 재공학(reengineering)

* 앞서 본 리팩토링(refactoring)은 소스코드라는 작은 범주에서의 일이라고 한다면, 시스템 재공학은 좀 더 큰 범위에서 시스템 전체나 일부를 새로운 시스템으로 대체하는 등 전체 구조를 뜯어 고치는 방식을 말한다.

### 유지보수 유형의 종류

* 수정 유지보수(corrective maintenance)
  * 결함 수리
* 적응 유지보수 (adaptive maintenance)
  * 새로운 환경, 새로운 요구사항에 적응
  * 새로운 환경에 적응시키는 것
* 완전 유지보수 (perfective maintenance)
  * 새로운 요구사항 구현 또는 시스템의 구조와 기능 개선
  * 요구사항을 완전하게 만든다. completence 완전성...
* 예방 유지보수 (preventive maintenance)
  * 장래 변경 시 발생할 수 있는 문제를 감소시킴
  * 문제가 생길 가능성을 줄이는 것

### 소프트웨어 재공학(Sofeware reengineering)

* 시스템 전체 또는 일부를 재구조화 하거나 다시 작성하는 것으로, 기존 시스템의 기능은 동일하게 유지하면서 유지보수하기 쉽고 이해하기 쉽도록 재구조화 하는 과정을 말한다.

### 소프트웨어 재공학의 활동

* 소스코드 변환 : 최신 버전이나 다른 언어로 변환
* **역공학(reverse engineering) ★** : **프로그램을 분석하고 정보를 추출**
  * **소스코드로부터 설계와 요구사항 등을 뽑아내겠다 하는 것**
  * 반복적인 개발일 때는 무조건 하게 된다. 언제든지 자주 할 수 있는 질문.
  * 우리도 프로젝트 할 때 개발하고 문서화 할 때 쓰니까 ㅋㅋㅋ
  * 뭐.. 실행 코드로부터 설계나 소스코드 등을 뽑아낼 수 있는 것도 포함이긴 함
* 프로그램 구조 개선 : 프로그램 제어 구조의 개선
* 프로그램 모듈화 : 중복성 제거 및 아키텍처 변환
* 데이터 재공학 : 데이터베이스 스키마 재정의, 데이터 정리

### 리팩토링(refactoring)

* 프로그램의 구조를 개선하고 복잡도를 줄여 이해하기 쉽도록 소스코드를 개선하는 것을 말하며, 기능 추가 등의 추가 개발보다는, 기존의 코드를 '개선' 하는데 집중한다.

### 재공학과 리팩토링

* 재공학은 일정기간 유지보수 후 유지보수 비용이 증가하고 있을 때 수행, '시스템'을 뜯어 고치는 큰 범주
* 리팩토링은 개발과 진화 과정 전반에 걸친 연속적인 개선 프로세스, '소스코드'를 수정하고 변경하는 범주



## 10 확실성 있는 시스템

### 확실성(dependability)의 주요 특성, 확실성의 다섯가지 요소

* 확실성에는 특정 시점에서 시스템이 서비스를 제공할 확률인 가용성-1,  주어진 기간동안 시스템이 고장 안나고 서비스를 제공할 확률인 신뢰성-2, 시스템이 사람이나 환경에 피해를 입히지 않을 확률인 안전성-3, 시스템이 침입을 막을 수 있는지에 대한 보안성-4, 장비 고장이나 공격 등으로부터 시스템이 중요한 서비스를 얼마나 잘 유지하는지에 대한 복원성-5 이라는 특징들이 존재한다.

* **가용성 (availability)** 
  * 어떤 **시점**에 시스템이 작동(서비스를 제공)할 확률
* **신뢰성 (reliability)**
  * 주어진 **기간**동안 시스템이 (정확하게) 서비스를 제공할 확률
  * 다시 말해, 그 기간동안 고장이 안날 확률
    * 정확성(correctness), 정밀성(precision), 적시성(timeliness) 포함
* **안전성 (safety)**
  * 시스템이 **사람** 또는 **환경**에 피해를 입히지 않을 확률
  * 요즘 강조되고 있는 부분
* **보안성 (security)**
  * 시스템이 (우연한 / 의도적인) **침입**을 막을 수 있는지
    * 무결성(integrity) 코드나 데이터를 위변조 못하게 막는것
    * 기밀성(confidentiality) 데이터를 빼가지 못하게 하는 것
* **복원성 (resilience)**
  * 시스템이 장비 고장, **공격** 등 아래에 중요한 서비스를 잘 유지하는지
  * 고장이 안나는 시스템은 없다. 근데 만약 공격 등이 있을 때 얼마나 잘 유지하는지

### 확실성 있는 프로세스 - 중복성과 다양성

* 어떤 시스템이나 프로세스든지 장애를 피할 수는 없다. 따라서 컴포넌트의 장애가 전체 장애로 이어지지 않도록 설계하는 것이 중요하다. 이 때 서버를 예를 들어 중복성과 다양성을 생각해볼 수 있는데, 서비스를 제공 못하는 상황을 시스템 전체 장애라고 두자. 그럼 서버의 다운을 피하기 위해 서버를 여러 대 두는 방법을 생각할 수 있다. 이것이 중복성에 해당한다. 하지만 동일한 SW와 HW, 동일한 오류라 한다면 하나의 서버를 마비시킨 오류가 다른 서버에서도 동일하게 발생해서 다 죽어버리는 상황이 발생할 수도 있다. 따라서 같은 방식으로 실패하지 않도록 서로 다른 중복 컴포넌트를 사용해는 것이 필요한데, 이것이 다양성에 해당한다.
* 즉, 가용성을 높이기 위해 중복된 서버를 사용하고, 서로 다른 유형의 서로 다른 운영체제 서버를 사용하는 등의 중복성, 다양성을 고려한다면 보다 더 확실성 있는 프로세스를 구축할 수 있을 것이다.
* 다만... 중복성과 다양성을 도입함에 따라 오히려 시스템의 복잡도가 올라가서 버그가 생길 수 있다. 그래서 오히려 중복성과 다양성을 피하는 것이 낫다는 주장도 존재한다.

### 확실성 있는 프로세스의 특징

* 확실성 있는 프로세스는 누가 봐도 딱 알 수 있도록 명시적으로 정의되어야 한다.
* 또한, 누가 하던지 간에 그 프로세스가 반복 가능해야 한다.



## 11 신뢰성 공학

### 결함-오류-고장(fault-error-failure) 모델

* 먼저 시스템 결함은 시스템 오류로 이어질 수 있는 시스템의 특성을 말한다. 그리고 시스템 오류는, 예기치 못한 시스템 행동으로 이어질 수 있는 시스템의 잘못된 '상태'를 말한다. 그렇다고 이 상태가 서비스 제공을 못하거나 프로그램이 아예 죽거나 한 상태인 것은 아니다 이 상태를 시스템 장애라고 하는데, 시스템이 서비스를 제공하지 못하는 시점의 사건을 말한다. 
* 즉, 결함-오류-고장 모델은 사람의 오류나 실수 등이 시스템 결함을 생기게 하고, 버그를 만들 수 있는데, 그러면 해당 시스템은 오류상태에 들어가고, 해당 오류는 고장(시스템 장애)으로 이어질 수 있다는 개념을 설명하는 모델이다.
* 하지만 결함이 반드시 오류를 초래하는 것은 아니고, 또 오류가 반드시 장애를 초래하지는 않는다. 하지만 결론적으로 '장애'를 막기 위한 목표로 시스템을 설계해 가야 한다.

### 결함 회피(fault avoidance) 

* 소프트웨어를 설계하거나 개발할 때 오류 발생 요소를 최소화 하거나 강한 자료형 언어를 사용하는 등 프로그래밍 오류를 피하는 방식으로, 애초에 사람이 실수할 가능성을 원천적으로 줄여 시스템에 도입되는 결함을 최소화하려는 방법을 말한다.

### 결함 감지 및 정정(fault detection & correction)

* 여러 검증 및 확인(V&V) 프로세스 들을 통해서 결함을 발견하고 버그를 잡겠다는 목적으로 수행하는 방법이다. (하지만 완벽한 방법은 없기에, 그럼에도 결함은 존재한다)

### 결함 내성(fault tolerance)

* 실행 중의 결함이나 시스템의 예기치 못한 행동을 감지하여 시스템 장애가 일어나지 않도록 설계하는 방법으로, 결함을 찾아내도 결함은 존재하니까... 결함이 있더라도 시스템이 서비스를 제공하는 상태는 유지할 수 있도록 하자는 목적으로 한다.

### 가용성과 신뢰성

* 신뢰성(Reliability)은 주어진 환경에서 특정 목적을 위해 지정된 시간(주어진 기간) 동안 고장 없이 운영될 확률을 말하고, 가용성(Availability)은 주어진 시점에서 시스템이 운영 중이고 요청된 서비스를 제공할 확률을 말한다.

### 신뢰성 척도

EX) 시스템 100일 간 운영 / 4번 고장 / 고장수리 1일

* 가용성 척도(AVAIL) : 가용성 = 운영시간 / 전체시간. ex) 100/104
  * 서비스 요구가 있을 때 시스템이 운영 중일 확률
* 고장 간 평균시간(MTTF) : ex) 100/4 = 25일
  * 고장 발생 비율(ROCOF)의 역수
* 고장 발생 비율(ROCOF) : ex) 4/100 = 0.04
  * 고장 간 평균시간(MTTF)의 역수
  * 어떤 시간 간격(또는 시스템 실행 횟수)동안 발생할 수 있는 시스템 장애 횟수



## 15 소프트웨어 재사용

### 애플리케이션 프레임워크(Application frameworks)

* 이미 사용할 기능들을 추상 클래스로 만들어 놓은 것을 내가 사용할 기능에 가져다가 쓰는 등, 애플리케이션을 쉽게 개발할 수 있게 해주는 프레임워크를 말한다. 구체적인 코드로 예를 들면, 상속을 받아 추상 메소드를 구현하는 등 GUI가 실제로 돌아가는 구체적인 동작 부분을 구현해 사용하면 된다.

### 서비스 지향 시스템(SOA : Service-oriented systems)

* 외부에서 제공되는 서비스를 연결(사용)하여 시스템을 개발하는 것을 말한다. 우편번호 검색을 예를 들면, 외부에서 우편번호 검색 시스템이 이미 DB로 있으면 그냥 그걸 요청해서 쓰면 되는 것!



## 17 분산 소프트웨어 공학

### 원격 프로시저 호출

* 다른 컴포넌트가 제공하는 서비스를 로컬 프로시저나 메소드처럼 호출하는 것을 만한다. 먼저 로컬 컴포넌트가 스텁을 호출하면 매개변수들은 전송 표준 표현으로 직렬화 되어 미들웨어를 통해 원격 프로시저에 요청을 보낸다. 원격 프로시저는 매개변수들을 다시 역직렬화 하여 계산을 수행하고, 미들웨어를 통해 결과를 반환하는 형태로 통신이 이루어진다.

### 미들웨어(middleware)

* 애플리케이션과 운영체제 사이에서 공통적인 서비스를 제공하는 서비스를 말한다.

### 스텁(stub)

* 실체가 있는 함수라기 보다는, 해당 기능의 인터페이스를 가진 함수를 말한다. 원격 프로시저 호출에서는 원격 프로시저의 인터페이스를 정의하고 있다.

### 분산 컴포넌트 아키텍처

* 서비스를 제공하고 사용하는 컴포넌트들의 집합으로 구성되어 있으며, 각 컴포넌트는 제공하는 서비스에 대한 인터페이스를 제공하고, 미들웨어를 통해 서비스를 호출하는 형태의 아키텍처를 말한다.

### 분산 컴포넌트 미들웨어

* 컴포넌트 간 상호작용을 관리하고 공통 서비스 집합을 제공하는 것을 말하며, 대표적으로 CORBA가 있다. (망함)

### CORBA

* 초기에는 고객이 만들어 달라는 기능을 전부 직접 구현하는 방식이었으나, 기능(서비스)의 개발을 하청을 주기로 하였다. 그래서 이런 컴포넌트들을 프로시저 호출처럼 쓰고 싶은데 그러려면 미리 정의를 해놓아야 하는 것. 그래서 필요한 서비스들을 이 Broker, 중개사를 통해서 찾자 하는 개념으로, 서비스를 찾고 / 구현한 기능을 제공하고 / 이들을 통신해주는 등 이런걸 해주는 미들웨어를 말한다.

### 분산 컴포넌트 모델의 장단점

* RPC, 원격 프로시저 호출 형태로 사용하는 방식이기 때문에, 서비스가 어디서 제공되어야 하는지 결정을 실행시까지 연기 가능하고, 새로운 자원을 추가하는 것이 쉬우며, 유연하고 확장성이 좋다. 또한 시스템을 동적으로 재구성할 수 있다는 장점이 있다.

  하지만 클라이언트-서버 시스템에 비해 복잡하다는 단점과, 표준 분산 컴포넌트 모델이나 미들웨어가 없다는 단점이있다.

### 피어-투-피어 아키텍처(peer-to-peer )

* 네트워크 상의 어떤 노드도 주어진 연산을 수행할 수 있는 방식인 비중앙집중적(decentralized) 방식을 기본으로 하며, 네트워크 상에 잠재적으로 존재하는 컴퓨터 자원들은 각각이 서버가 될 수도, 클라이언트가 될 수도 있는 구분이 없는 방식을 말한다.
* 반-집중(semicentralized) 방식의 경우에는, 슈퍼피어(super peer)라고 하는 중심이 되는 노드가 있어서 각 노드들에게 정보를 제공하고, 작업을 분배하며, 결과를 수집하고 점검하는 등의 방식으로 구성된다.

### 서비스로서의 소프트웨어(SaaS : Software as a service)

* 소프트웨어는 서버에 설치되어 실행되고, 웹 브라우저를 통해 접근하는 클라이언트에게 원격 서버가 기능을 제공하는 방식을 말한다. 대표적으로 Google Docs나 오피스 365등의 예시가 있으며, 클라우드 컴퓨팅 발전으로 보급이 늘어나고 있다.



## 18 서비스 지향 소프트웨어 공학

### 서비스 지향 아키텍처 (Service-Oriented Architecture : SOA)

- 소프트웨어의 기능을 서비스(컴포넌트)라고 보았을 때, 여러 제공자들로부터 호출하여 작업을 수행하고, 결과를 반환받는 형태로 시스템을 구성하는 방식의 아키텍처를 말한다. 즉, 더 큰 단위의 서비스를 제공하기 위해서 서비스 기능들을 직접 다 구현하는것이 아니라 서비스를 제공하는 제공자들의 기능들을 모아서 전체 시스템을 구축해나가는 방법을 말한다.
- 외부 제공자에게 서비스를 아웃소싱이 가능하고, 서비스는 언어 독립적이라는 장점이 있다. 또한 단순화된 정보 교환을 통해 조직 간의 컴퓨팅이 가능하다.

### SOA 구조

* 서비스를 설계하고 구현하여 서비스에 대한 인터페이스 명세를  WSDL로 만들어 정보를 레지스트리에 등록하는 서비스 제공자, 서비스 명세를 검색해 제공자를 찾고 SOAP을 이용해서 요청하는 서비스 요청자, 서비스가 등록되는 레지스트리가 존재한다.

### SOAP(Simple Object Access Protocol)

* XML 형식의 메시지로, 서비스 메시지 교환 표준을 말하며, 서비스 요청자가 제공자에게 서비스를 요청할 때 SOAP 메시지를 보내서 제공 받는다.

### WSDL(Web Service Description Language)

* XML 형식의 메시지로, 서비스 인터페이스를 정의하는 표준을 말하며, 서비스 제공자가 서비스를 설계하고 WSDL를 이용해 인터페이스, 요청 형식, 응답 형식 등을 스펙으로 작성하여 레지스트리에 등록하는 것이다.

### RESTful 서비스

* SOAP / WSDL을 이용한 XML 웹서비스 표준은 너무 무겁고 비효율적이기 때문에 XML의 대안으로 만든 방법이며, 오버헤드가 적고 효율적이다.



## 23 프로젝트 계획 수립

### 이정표**(milestone)** 

* 프로젝트의 진척 사항을 측정할 수 있는 일정의 특정 지점을 말하며, 어디까지 왔다 하는 것을 이정표를 통해 알 수 있다. (테스팅을 위해 시스템을 인도하는 때 등) 하지만 이정표가 있다고 해서 산출물이 꼭 있는것은 아니다.

### 산출물(deliverable)

* 고객에게 인도되는 작업의 결과물을 말하며, 증분 또는 요구사항 문서 등이 해당한다. 특정 산출물이 나오는 것을 이정표로 삼을 수도 있다.

### 프로젝트 일정관리 시

* 안해본 것 먼저, 반복적(iterative), 점진적(increment)으로 접근해야 한다!!

### 액티비티 네트워크

* 종속성이 없는 태스크를 먼저 그린다.
* 반드시 화살표로 그리자. 마지막 갈데 없는 녀석은 Finish로
* 일을 병행해서 작업의 시작일자 / 종료일자를 미룰 수 있다,

### 임계 경로(critical path)

* 소요 시간이 가장 긴 경로를 말한다. 즉, 프로젝트가 최대한 빨리 마친다는 가정 하에 적어도 필요한 최소한의 기간

### 표, 액티비티 네트워크, 바차트, 임계경로



## 25 형상관리

### 코드라인(codeline)

* 컴포넌트(하나의 소스코드) 파일의 일련의 버전들 즉, 해당 소스코드 파일의 흐름을 말한다. (a.java 소스코드 파일의 버전)

### 베이스라인(baseline)

* 하나의 시스템을 구성하는 컴포넌트들의 버전 모음으로, 특정 시스템 버전에 대한 정의를 말한다. 베이스라인은 구성된 컴포넌트로부터 다시 생성할 수 있다.

### 메인라인(mainline)

* 시스템 각각의 버전인 베이스 라인들은 계속해서 업그레이드가 될텐데, 이 코드들의 전체적인 흐름을 메인라인이라고 말한다. 즉, 메인 라인은 그 전체적인 프로젝트의 흐름을 말한다.

### 분기(branch)

* 기존 코드라인 내 버전에서 새로운 코드라인을 생성하는 것으로, 버그픽스나 팀별 작업 등의 목적으로 브랜치를 생성할 수 있다. 이렇게 생성된 분기(새로운 코드라인)는 독립적으로 개발 가능하다. 코드 진행이 완료되면 메인 브랜치에 merge 한다.

### 병합(merge)

* 서로 다른 코드라인의 버전들을 병합하여 새로운 버전을 생성하는 것을 말한다. 일반적으로 다른 코드라인은 분기에 의해 생성된 것. 공통 조상이 있는 녀석은 3way merge 라고 하고, 없는 녀석은 2way merge라고 한다.

### 중앙집중 버전관리 시스템

* 마스터 저장소에 컴포넌트의 모든 버전을 유지하는 방식으로, 중앙에 공유되는 하나의 저장소에 다 넣어놓고 모든 버전을 관리하자는 것이다. 이걸 수정하기 위해서는 체크아웃(복사) 하여 개인저장소로 가져가 작업을 수행하고, 끝나면 체크인을 하여 저장소에 새로운 버전을 생성한다.
* 체크아웃 → 작업 → 체크인 방식이며, 동시에 체크아웃 할 경우 이를 막는 방식 / 또는 두 버전이 생성되는 방식으로 할 수 있다.

### 체크아웃(check-out)

* 수정하기 위해 프로젝트 저장소에서 개인 작업공간으로 복사해오는 과정

### 체크인(check-in)

* 변경을 완료한 뒤 작업 내용을 저장소에 반영하는 과정, 새로운 버전을 생성

### 분산 버전관리 시스템

* 컴포넌트 저장소의 여러 버전이 존재하는 방식으로, 기본적으로 서버에 마스터 저장소가 존재하지만 여러 개의 저장소를 개발자들 local pc에 각각 가지고 있고 그걸 나중에 반영하는 형식으로 버전을 관리하자는 것이다. 물론 이 방식도 반영이 되는 마스터 저장소가 있기는 하지만, 그걸 개인 Local repository로 그대로 clone(복사)해올 수 있고, 이를 commit하여 local repository를 갱신하며, 변경 사항을 마스터 저장소에 push(반영)할 수 있다. 또한 pull을 통해 저장소의 변경을 local에 가져올 수 있다.

### 델타(delta)

* 라인 단위로 분석한 버전간의 차이를 델타라고 한다. 가장 초기버전을 완벅하게 저장하고 이후 버전을 생성하기 위한 델타를 관리하는 전향델타(forward delta)와, 가장 최근버전을 완전하게 저장하고 이전 버전을 생성하기 위한 델타를 관리하는 후향 델타(backward delta) 방식이 존재한다. 당연히 최근 버전을 사용자들이 더 많이 쓸테니 후향 델타 방식을 주로 이용한다.

### 태그(tag)

* 태그 또는 레이블이라고 하며, 의미 있는 이름으로 필요에 따라 태그나 레이블을 잘 붙여야 한다. 이는 필요에 따라 여러 개가 붙을 수도 있고, 안붙을 수도 있다. 태그는 특정 베이스라인을 찾아내는 것이 목적이다.



## 12 안전성 공학

### 안전성의 정의

* 사람의 사망이나 부상을 초래할 위험이 없고 시스템 환경(자연)에 대한 손상(피해) 없이 (정상 또는 비정상적으로) 작동하는 시스템의 능력을 반영하는 속성을 말한다.

### 신뢰할 수 있지만(명세대로 서비스를 제공 하더라도) 안전하지 않은 시스템

* 특정 위기 상황에 필요한 행동이 명세에 없는 등 요구사항이 불완전하기 때문에 이런 경우가 발생한다. (요구사항에 시스템 안전을 위해 필요한 행위를 반영하지 않음) 따라서 이를 해결하기 위해 안전성 요구사항이 요구된다.

### hazard(위험원)

* 사고로 연결될 수 있는 상황이나 사건(부품 고장, 계산 오류)을 말하며, 위험원이 항상 사고로 이어지는 것은 아니다.

### 안전성 용어

* 손실(damage) : 사고로 인한 피해
* 위험(hazard) : 사고의 원인이 되거나 기여하는 잠재적인 요인이나 조건
* 위험 확률(hazard probability) : 위험의 발생 확률
* 위험 심각도(hazard severity) : 위험으로부터 생길 수 있는 손실에 대한 평가
* 리스크(risk) : 확률에 대한 개념으로, 시스템이 사고를 낼 가능성을 반영해서 리스크라고 한다.
  * 위험이 곧 사고로 이어지지는 않지만, 위험을 식별해서 리스크를 낮춰야 한다.