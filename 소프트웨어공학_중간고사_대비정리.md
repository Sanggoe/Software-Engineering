### 소프트웨어 공학 중요한 내용 정리



### 소프트웨어 공학 활동 (개발 과정)

* **명세**(specification) : 요구사항 분석
* **개발**(development) : 설계, 구현
* **검증**(validation) : 테스팅 (시험)
* **진화**(evolution) : 유지 보수



### 계획 주도 개발 (plan-driven)

* 특징
  * 대표적으로 폭포수(waterfall) 모델이 있음
  * 전체 시스템을 개별적인 프로세스 단계로 구분하여 개발하는 방법
  * 각 단계별로 나오는 산출물(문서)이 중요
  * 단계별로 나오는 산출물을 토대로 다음 단계를 진행
* 장점
  * 프로세스 단계로 구분하여 진행되기 때문에 단계별로 진행되는 과정 가시적
  * 요구사항 이해도가 높으며 변경이 적은, 그리고 대규모 프로젝트에서 유용
  * 안전성(safety) 중심 시스템 같이, 완벽한 분석이 필요한 경우에 적당함
* 단점
  * 신속한 S/W 개발에는 적합하지 않음
  * 변화하는 고객의 요구사항에 대응하기 어려움
  * 만약 이전 단계에서 문서를 수정하면 프로세스 지연 및 비용이 증가함
  * 문서↓소통↑ 한 경우에는 반복적(iterative)개발 (점증적)과 애자일(agile)방법이 적합



### 점증적(incremental) 개발

* 특징
  * 애자일 개발이 대표적
  * 명세, 개발, 검증 활동이 중첩됨
  * 계획 주도 개발과 다르게 명확하게 단계를 구분하는 것이 아님
  * 시스템은 일련의 증가분(increment)으로 개발되며, 증분이 고객에게 제공됨
* 장점
  * 빠른 개발의 경우 주로 사용
  * 개발된 내용에 대한 고객 피드백 받기 쉬움
  * 요구사항 변경을 구현하는 비용이 줄어듦
  * 일부 유용한 기능만 포함한 S/W를 고객에게 전달해 사용하도록 할 수 있음(증분)
* 단점
  * 프로세스가 가시적이지 않음 - 진척도 측정을 위한 산출물 필요
  * 대규모 시스템 개발에는 적합하지 않음
  * 새로운 증분 추가에 따라 시스템 구조가 저하되는 경향
  * 구조 저하와 코드 복잡도를 줄이기 위해 정기적 리팩토링(refactoring)이 필요



### 애자일 개발 (agile)

* 특징
  * 명세와 설계 및 구현이 중첩되므로, 설계 문서를 최소화
  * 시스템을 연속적인 증분(increment)으로 구현하며, 이해당사자가 증분의 명세화, 평가에 참여
  * 전체 과정을 반복하면서 개발, 점증적 인도
  * XP, 스크럼(Scrum) 등의 방법이 있음
* 장점
  * 신속한 S/W 개발과 인도가 중요
  * 요구사항 자주 변경되는 (이해도↓) 프로젝트에 적합
  * 작동하는 S/W를 점증적으로 개발해서 고객에게 인도
* 단점
  * 점증적 개발의 단점과 유사



### 리팩토링 (Refactoring)

* 소프트웨어의 구조와 코드의 가독성을 개선하는 작업을 말하며, 클래스의 계층 구조를 변경하거나 코드의 중복을 줄이는 것, 변수나 메소드의 이름을 적절히 변경하는 것 등의 예시가 모두 리팩토링 활동에 해당된다.
* XP나 애자일 기법 등 점증적 개발 방법에서 리팩토링을 진행하는 것이 중요하다고 알려져 있는데, 사실 어떤 경우에도 코드의 변경은 반드시 일어나므로, 소프트웨어 개발에 있어서 리팩토링은 매우 중요하다고 볼 수 있다!!



### 테스트 주도 개발 (Test-Driven-Development)

* 코드를 작성하기 전에 테스트를 먼저 작성하는 식으로 개발하는 기법을 말한다. TDD라는 약자로 사용하며, 테스트 작성을 위해서는 기능과 인터페이스에 대해 알아야 하므로 요구사항을 명확히 할 수 있다는 장점이 있다. 또한 일반적으로, Junit 등의 자동화된 테스팅 프레임워크를 필수적으로 사용한다.



### 기능적 요구사항 (functional)

* 기능적 요구사항은, 시스템이 제공하는 서비스나 기능에 대한 요구사항을 말한다. 이를 통해 시스템이 무엇을 해야 하고 하지 말아야 하는지, 특정 입력이나 상황에 어떻게 반응하고 행동하는지에 대해 기술한 것이라고 보면 된다. 현실적으로는 그렇지 못하지만.. 요구사항은 모든 서비스와 정보가 정의 되어야 한다는 완전성과, 충돌하거나 모순되는 요구사항이 없어야한다는 일관성을 만족하는 것을 추구해야한다.



### 비기능적 요구사항 (non-functional)

* 비기능적 요구사항은 서비스나 기능의 '제약조건'에 대한 것으로, 서비스가 아닌 요구사항 영역을 말한다. 보안성이나 안전성, 신뢰성 등을 포함한 부분들을  비기능적 요구사항이라 하며, 이런 요구사항들이 만족되지 않는 것이 기능적 요구사항을 만족하지 않는 경우보다 심각할 수 있다. 또한 비기능적 요구사항은 특정 컴포넌트보다는 시스템 전체 아키텍처에 영향을 받는 편이다.



### UML 유스케이스 모델 (use case) / 유스케이스 다이어그램

* 요구사항을 명세하는 과정에서 기능적 요구사항에 대한 부분을 표현하기 위한 모델이다.
* 구성 요소로는 유스케이스와 액터가 있으며, 이들 사이의 관계를 연관(association)이라고 부른다.
* 시스템 모델링 관점에서 유스케이스 모델은 상호작용 모델에 해당하지만, 어떤 기능이 있고 그걸 누가 사용하는지 정적으로 보여주기 때문에 유스케이스를 '상호작용 모델'로 보기에는 한계가 있다고도 본다.

#### 유스케이스

* 시스템이 제공하는 기능을 말하는데, 여기서 '기능'으로 분류하는 정도는 모델링 하는 사람에게 달렸지만... 보통은 사용자의 목표, 목적을 달성하는 정도를 기준으로 기능을 분류한다. 따라서 목적 달성에 대한 기능 위주로 표시하기 때문에, 관련된 시나리오에 대한 부분의 집합이라고 볼 수 있다.

#### 액터 (actor)

* 시스템과 직접 상호작용을 하는 모든 '역할'을 말한다. 즉, 사람도 액터가 될 수 있지만, 시스템이 아닌 또 다른 시스템이나 기계 등 시스템이 사용되고 운영될 때 직접 사용되는 모든 것이 액터가 될 수 있다.



### UML 시퀀스 다이어그램

* 시스템과 사용자, 또 다른 시스템, 또는 시스템 컴포넌트간의 상호작용까지 나타낼 수 있는 것이 시퀀스 다이어그램이다. 시스템 모델링 관점에서 시퀀스 다이어그램은 상호작용 모델에 해당하며, 실제로 사용되는 실제 시나리오를 동적으로 표현하는데 사용한다.
* 요구사항 분석 단계에서, 시스템과 액터 사이에 어떻게 상호작용을 하는가를 설명하기 위해 활용할 수 있다...
* 또는 설계 단계에서, 유스케이스의 실제 구체적인 시나리오를 동적으로 표현하는데 활용할 수 있다!!



### 클래스 다이어그램

* 구조 모델의 대표선수
* 등장인물의 관계도 그려놓은 것이지만, 각 회차별 시나리오를 알지는 못한다.



### 상태 다이어그램

* 내부 / 외부 이벤트에 대한 시스템의 반응을 보여줌
* 이녀석이 동작 모델의 대표선수이다. 다만 얘는 필요하면 만드는 것



### verification & validation

* verification : 시스템이 명세대로 만들어졌는지 즉, SPEC에 맞는 소프트웨어를 개발했느냐에 대한 검증을 말한다.
* validation : 시스템이 고객이 원하고 실제로 도움이 되는 필요한 시스템인가? 에 대한 검증을 말한다.



### 검증테스팅(validation testing)과 결함테스팅(defect testing)

* validation testing의 경우에는, '정상적인 데이터'로 프로그램이 의도한 대로 잘 돌아가는지 확인하는 테스팅을 말한다.
* detect testing의 경우에는, '이상한 입력'을 통해서 결함을 찾아내는 테스팅을 말한다.



### 인스펙션과 테스팅

* 인스펙션
  * 소프트웨어 인스펙션이란, 프로그램을 실행시키지 않는 **정적 V&V기술**이며, 주로 소스코드를 대상으로 한다.
  * 요구사항이나 설계, 소스코드 등을 분석하고 검사해서 문제를 찾는다.
  * 정적 프로세스이기에 오류간 상호작용과는 무관하다.
  * 소스코드를 쫙 읽으며 한 번에 여러 오류를 발견할 수 있다.
  * 결함을 찾는 것 뿐 아니라 표준 준수, 이식성, 유지보수성 등 품질 속성을 검토할 수 있다.
  * SW 안전성 이라던가. 눈으로 코드를 보는 인스펙션 과정을 통해서만 볼 수 있는 것들이 있다.
* 테스팅
  * 소프트웨어 테스팅은, 프로그램을 실제로 실행시켜 동작을 관찰하는 **동적(dynamic) V&V 기술**

* 따라서 인스펙션(정적)과 테스팅(동적, 실행)은 상호 보완적인 관계이다.
  * 인스펙션이 테스팅을 대체할 수는 없다.
  * 시스템 컴포넌트 간 상호작용, 타이밍, 성능



### 테스트 케이스(test case)

* 무엇을 테스트 하는지에 대한 케이스로, 테스트 입력을 위한 데이터, 그리고 입력에 따른 예상 출력인 결과가 있다.
  * 테스트 데이터 : 시스템을 테스트 하기 위한 입력
  * 테스트 결과 : 테스트 데이터 입력에 따른 출력



### 회귀 테스팅 (regression testing)

* 프로그램의 변경으로 새로운 버그가 생기지 않았는지 점검하기 위하여 이전에 수행한 테스팅을 모두 다시 테스팅 하는 것을 말한다. 그렇기 때문에 이를 위해서 테스트 자동화를 위한 기술이 필수적으로 요구된다.



### 동등 분할(equivalence partition)과 분할 테스팅(partition testing)

* 단위 테스팅을 할 때 테스트 케이스 선정을 위한 전략의 종류중 하나로, 동등분할은 입력 또는 출력에 대해서 '공통 특징을 가진 그룹'으로 나누는 것을 말한다.
* 그리고 분할 테스팅은, 그렇게 그렇게 입력과 출력 데이터에 대해 나누어서 그룹별로 적어도 하나 이상씩은 테스트 케이스를 선별해야 하지 않겠느냐? 하는 관점에서, 테스트 케이스를 선정하고 테스팅하는 과정이 분할 테스팅이다.
* 즉 다시 정리하면, 분할테스팅을 하기 위해 앞서 공통 특징을 가진 그룹으로 나누는 과정이 동등 분할 과정인 것이다.